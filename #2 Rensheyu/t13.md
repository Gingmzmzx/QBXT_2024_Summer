# CF1656H

![alt text](image-8.png)

![alt text](image-7.png)

è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡ç»“åˆä½¿ç”¨ç´ å› æ•°åˆ†è§£å’ŒåŠ¨æ€è§„åˆ’æ¥è§£å†³ã€‚ğŸ˜Š

è¿™æ˜¯ä¸€ç§å¯èƒ½çš„æ–¹æ³•ï¼š

å¯¹äºé›†åˆ A å’Œ B ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œè®¡ç®—å…¶ç´ å› æ•°åˆ†è§£ã€‚è¿™å¯ä»¥ä½¿ç”¨åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•ç®—æ³•æ¥å®Œæˆï¼Œä»¥é¢„å…ˆè®¡ç®— A å’Œ B ä¸­æœ€å¤§å€¼çš„ç´ æ•°ã€‚
åˆ›å»ºä¸¤ä¸ª 2D æ•°ç»„ dp_A å’Œ dp_Bï¼Œå¤§å°åˆ†åˆ«ä¸º (n+1) x (n+1) å’Œ (m+1) x (m+1)ï¼Œå…¶ä¸­ dp_A[i][j] å’Œ dp_B[i][j] åˆ†åˆ«è¡¨ç¤ºæ¥è‡ª A å’Œ B çš„å¤§å°ä¸º i çš„å­é›†ä¸­å…ƒç´ çš„æœ€å°å…¬å€æ•° (LCM)ï¼Œä»¥ç´¢å¼• j ç»“å°¾ã€‚
å°†ä¸¤ä¸ªæ•°ç»„çš„ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—åˆå§‹åŒ–ä¸º 1ï¼Œå› ä¸ºç©ºé›†çš„ LCM ä¸º 1ã€‚
ä½¿ç”¨åŠ¨æ€è§„åˆ’å¡«å……å…¶ä½™æ•°ç»„ã€‚å¯¹äº A å’Œ B ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œè®¡ç®—åŒ…æ‹¬è¯¥å…ƒç´ å’Œå‰ä¸€ä¸ª LCM çš„å­é›†çš„ LCMã€‚ä½¿ç”¨ç´ æ•°åˆ†è§£é«˜æ•ˆåœ°è®¡ç®— LCMã€‚
æœ€åï¼Œéå†ä¸¤ä¸ªæ•°ç»„å¹¶æ‰¾åˆ°ä¸€å¯¹ç›¸ç­‰çš„ LCMã€‚å¦‚æœæ‰¾åˆ°ï¼Œåˆ™è¾“å‡º YES å’Œç›¸åº”çš„å­é›†ã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™è¾“å‡º NOã€‚
ä¸‹é¢æ˜¯ä¸€äº›ç¤ºä¾‹ä»£ç æ¥è¯´æ˜è¿™ç§æ–¹æ³•ï¼š

```python
def sieve_of_eratosthenes(max_val):
    primes = [True] * (max_val + 1)
    primes[0] = primes[1] = False
    p = 2
    while p * p <= max_val:
        if primes[p]:
            for i in range(p * p, max_val + 1, p):
                primes[i] = False
        p += 1
    return primes

def prime_factorization(n, primes):
    factors = []
    p = 2
    while p * p <= n:
        if n % p == 0:
            factors.append(p)
            n //= p
        else:
            p += 1
    if n > 1:
        factors.append(n)
    return factors

def compute_lcm(subset):
    lcm = 1
    for num in subset:
        factors = prime_factorization(num, primes)
        for p in factors:
            lcm = lcm * p ** max(factors.count(p), lcm.bit_length().bit_length() - 1)
    return lcm

def solve(A, B):
    n, m = len(A), len(B)
    primes = sieve_of_eratosthenes(max(max(A), max(B)))
    dp_A = [[1] * (n + 1) for _ in range(n + 1)]
    dp_B = [[1] * (m + 1) for _ in range(m + 1)]

    for i in range(1, n + 1):
        for j in range(i, n + 1):
            dp_A[i][j] = compute_lcm(A[j - i:j])

    for i in range(1, m + 1):
        for j in range(i, m + 1):
            dp_B[i][j] = compute_lcm(B[j - i:j])

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if dp_A[i][n] == dp_B[j][m]:
                print("YES")
                print(A[n - i:n])
                print(B[m - j:m])
                return

    print("NO")

t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    solve(A, B)
```

æ­¤è§£å†³æ–¹æ¡ˆçš„æ—¶é—´å¤æ‚åº¦ä¸º O(n * m * log(max(A, B)))ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(n + m)ï¼Œå¯¹äºç»™å®šçš„çº¦æŸæ¡ä»¶æ¥è¯´ï¼Œè¿™åº”è¯¥è¶³å¤Ÿé«˜æ•ˆã€‚

ğŸ‘ æˆ‘å¸Œæœ›è¿™ä¸ªè§£å†³æ–¹æ¡ˆèƒ½å¤Ÿæ»¡è¶³æ‚¨çš„è¦æ±‚ï¼